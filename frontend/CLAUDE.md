# CLAUDE.md

This file provides guidance to Claude Code when working with the frontend application.

## Project Overview

Next.js-based message management application with full CRUD functionality.

## Tech Stack

- **Framework**: Next.js 15+ (App Router)
- **Language**: TypeScript
- **UI Library**: shadcn/ui
- **Styling**: Tailwind CSS v4
- **Package Manager**: pnpm
- **API Code Generation**: Orval (OpenAPI → TypeScript + React Query hooks)
- **HTTP Client**: axios
- **State Management**: TanStack Query (React Query)
- **Form Management**: React Hook Form + Zod
- **Testing**: Vitest + Testing Library + Playwright (E2E)
- **Component Development**: Storybook 10+ with MSW integration
- **Dev Server Port**: 3000
- **Storybook Port**: 6006

## Build Commands

```bash
# Install dependencies
pnpm install

# Generate API client from OpenAPI spec (run after backend changes)
pnpm generate:api

# Development
pnpm dev

# Build
pnpm build

# Production
pnpm start

# Test (unit & component)
pnpm test

# E2E test
pnpm test:e2e

# Lint
pnpm lint

# Type check
pnpm type-check

# Storybook
pnpm storybook           # Start Storybook dev server (port 6006)
pnpm build-storybook     # Build Storybook for production
```

## Tailwind CSS v4 Migration

This project uses **Tailwind CSS v4**, which introduced significant changes from v3:

### Key Changes

1. **PostCSS Plugin Separation**
   - The PostCSS plugin is now in a separate package: `@tailwindcss/postcss`
   - Updated `postcss.config.js` to use `@tailwindcss/postcss` instead of `tailwindcss`

2. **New CSS Import Syntax**
   - Changed from `@tailwind` directives to `@import "tailwindcss"`
   - `src/app/globals.css` now uses the new v4 syntax

3. **Dark Mode Configuration**
   - `darkMode` in `tailwind.config.ts` changed from array `['class']` to string `'class'`

4. **Removed @apply Usage**
   - Replaced `@apply` directives with direct CSS properties
   - Example: `@apply border-border` → `border-color: hsl(var(--border))`

### Configuration Files

**postcss.config.js**:

```javascript
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
};
```

**tailwind.config.ts**:

```typescript
const config: Config = {
  darkMode: 'class', // Changed from ['class']
  // ... rest of config
};
```

**src/app/globals.css**:

```css
@import 'tailwindcss';

:root {
  /* CSS variables */
}

* {
  border-color: hsl(var(--border));
}

body {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}
```

### Migration Notes

- The `tailwind.config.ts` file is still supported and used for theme customization
- CSS variables (e.g., `--background`, `--foreground`) continue to work as before
- shadcn/ui components are fully compatible with v4
- No changes required in component files

### Resources

- [Tailwind CSS v4 Documentation](https://tailwindcss.com/docs)
- [v4 Migration Guide](https://tailwindcss.com/docs/upgrade-guide)

## Project Structure

```
frontend/
├── src/
│   ├── app/                    # Next.js App Router
│   │   ├── layout.tsx          # Root layout
│   │   ├── page.tsx            # Home page (message list)
│   │   └── globals.css         # Global styles
│   │
│   ├── components/             # React components
│   │   ├── ui/                 # shadcn/ui components
│   │   ├── messages/           # Message-specific components
│   │   │   ├── MessageTable.tsx
│   │   │   ├── MessageModal.tsx
│   │   │   ├── MessageForm.tsx
│   │   │   ├── SearchBar.tsx
│   │   │   └── DeleteConfirmDialog.tsx
│   │   └── common/             # Common components
│   │       ├── Loading.tsx
│   │       └── ErrorBoundary.tsx
│   │
│   ├── lib/                    # Utility functions
│   │   ├── api/                # API client
│   │   │   ├── generated/      # Orval generated code (DO NOT EDIT)
│   │   │   │   ├── messages.ts # Generated API functions & types
│   │   │   │   └── messages.msw.ts # MSW handlers (for testing)
│   │   │   └── client.ts       # Axios instance configuration
│   │   ├── validations/        # Zod schemas
│   │   │   └── message.ts
│   │   └── utils.ts            # Helper functions
│   │
│   ├── hooks/                  # Custom React hooks
│   │   └── useDebounce.ts      # Debounce hook for search
│   │
│   └── types/                  # TypeScript types (manual)
│       └── common.ts           # Common type definitions
│
├── public/                     # Static files
├── tests/                      # Test files
│   ├── unit/
│   ├── component/
│   └── e2e/
├── orval.config.ts             # Orval configuration
├── tailwind.config.ts
├── tsconfig.json
├── next.config.js
├── vitest.config.ts
├── playwright.config.ts
└── package.json
```

**Note**: The `src/lib/api/generated/` directory is auto-generated by Orval. Do NOT manually edit files in this directory.

## Features

### Message List Page (/)

- **Display**: Responsive table showing all messages
  - Columns: ID, Code, Content, Actions
  - Mobile: Card-based layout

- **Search/Filter**:
  - Search by code or content (debounced)
  - Real-time filtering

- **Sort**:
  - Click column headers to sort (ascending/descending)
  - Sort by: ID, Code, Content

- **Pagination**:
  - Default: 10 items per page
  - Options: 10, 25, 50, 100

- **Actions**:
  - New Message button → Opens create modal
  - Edit button (per row) → Opens edit modal
  - Delete button (per row) → Shows confirmation dialog

### Message Modal (Create/Edit)

- **Fields**:
  - Code (required, unique, max 50 chars)
  - Content (required, max 500 chars)

- **Validation**:
  - Client-side: React Hook Form + Zod
  - Real-time validation feedback
  - Error messages displayed under each field
  - Server-side validation errors also displayed

- **Buttons**:
  - Save: Submit form
  - Cancel: Close modal without saving

### Delete Confirmation Dialog

- **Message**: "Are you sure you want to delete this message?"
- **Details**: Show code and content preview
- **Buttons**:
  - Delete: Confirm deletion
  - Cancel: Close dialog

## API Code Generation (Orval)

### Overview

This project uses **Orval** to automatically generate TypeScript API client code and React Query hooks from the backend's OpenAPI specification.

**Benefits**:

- Type-safe API calls with zero manual typing
- Automatic React Query hooks generation
- Synced with backend API changes
- MSW handlers for testing

### Configuration

Orval is configured in `orval.config.ts`:

```typescript
import { defineConfig } from 'orval';

export default defineConfig({
  api: {
    input: '../backend/src/main/resources/api/openapi.yaml',
    output: {
      target: './src/lib/api/generated/messages.ts',
      client: 'react-query',
      httpClient: 'axios',
      mode: 'single',
      override: {
        mutator: {
          path: './src/lib/api/client.ts',
          name: 'customInstance',
        },
      },
    },
  },
});
```

### Axios Instance Configuration

Create a custom axios instance with base URL and interceptors:

```typescript
// src/lib/api/client.ts
import axios, { AxiosRequestConfig } from 'axios';

export const AXIOS_INSTANCE = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080/api',
});

// Request interceptor (add auth token, etc.)
AXIOS_INSTANCE.interceptors.request.use(
  (config) => {
    // Add authorization header if needed
    // const token = getAuthToken();
    // if (token) {
    //   config.headers.Authorization = `Bearer ${token}`;
    // }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor (handle errors globally)
AXIOS_INSTANCE.interceptors.response.use(
  (response) => response,
  (error) => {
    // Handle common errors (401, 403, 500, etc.)
    if (error.response?.status === 401) {
      // Handle unauthorized
    }
    return Promise.reject(error);
  }
);

// Custom instance for Orval
export const customInstance = <T>(config: AxiosRequestConfig): Promise<T> => {
  const source = axios.CancelToken.source();
  const promise = AXIOS_INSTANCE({
    ...config,
    cancelToken: source.token,
  }).then(({ data }) => data);

  // @ts-ignore
  promise.cancel = () => {
    source.cancel('Query was cancelled');
  };

  return promise;
};
```

### Generated Code Structure

After running `pnpm generate:api`, Orval generates:

```typescript
// src/lib/api/generated/messages.ts

// Type definitions (auto-generated from OpenAPI)
export interface MessageResponse {
  id: number;
  code: string;
  content: string;
}

export interface MessageRequest {
  code: string;
  content: string;
}

// API functions (auto-generated)
export const getAllMessages = (options?: AxiosRequestConfig) =>
  customInstance<MessageResponse[]>({ url: '/messages', method: 'GET', ...options });

export const getMessageById = (id: number, options?: AxiosRequestConfig) =>
  customInstance<MessageResponse>({ url: `/messages/${id}`, method: 'GET', ...options });

export const createMessage = (messageRequest: MessageRequest, options?: AxiosRequestConfig) =>
  customInstance<MessageResponse>({
    url: '/messages',
    method: 'POST',
    data: messageRequest,
    ...options,
  });

export const updateMessage = (
  id: number,
  messageRequest: MessageRequest,
  options?: AxiosRequestConfig
) =>
  customInstance<MessageResponse>({
    url: `/messages/${id}`,
    method: 'PUT',
    data: messageRequest,
    ...options,
  });

export const deleteMessage = (id: number, options?: AxiosRequestConfig) =>
  customInstance<void>({ url: `/messages/${id}`, method: 'DELETE', ...options });

// React Query hooks (auto-generated)
export const useGetAllMessages = <TData = MessageResponse[]>(
  options?: UseQueryOptions<MessageResponse[], Error, TData>
) => useQuery(['getAllMessages'], () => getAllMessages(), options);

export const useGetMessageById = <TData = MessageResponse>(
  id: number,
  options?: UseQueryOptions<MessageResponse, Error, TData>
) => useQuery(['getMessageById', id], () => getMessageById(id), options);

export const useCreateMessage = <TError = Error>(
  options?: UseMutationOptions<MessageResponse, TError, { data: MessageRequest }>
) => useMutation((params) => createMessage(params.data), options);

export const useUpdateMessage = <TError = Error>(
  options?: UseMutationOptions<MessageResponse, TError, { id: number; data: MessageRequest }>
) => useMutation((params) => updateMessage(params.id, params.data), options);

export const useDeleteMessage = <TError = Error>(
  options?: UseMutationOptions<void, TError, { id: number }>
) => useMutation((params) => deleteMessage(params.id), options);
```

### Usage in Components

Import the generated hooks directly:

```typescript
// components/messages/MessageTable.tsx
import { useGetAllMessages, useDeleteMessage } from '@/lib/api/generated/messages';

export function MessageTable() {
  const { data: messages, isLoading, error } = useGetAllMessages();
  const deleteMutation = useDeleteMessage({
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries(['getAllMessages']);
    },
  });

  const handleDelete = (id: number) => {
    deleteMutation.mutate({ id });
  };

  // ...
}
```

### Workflow

1. **Backend makes API changes** → Updates OpenAPI spec
2. **Backend regenerates OpenAPI**: `cd backend && ./mvnw verify`
3. **Frontend regenerates client**: `cd frontend && pnpm generate:api`
4. **Type-safe code**: Frontend automatically has updated types and functions

### Important Notes

- **DO NOT** manually edit files in `src/lib/api/generated/`
- Always use generated hooks instead of raw axios calls
- Re-run `pnpm generate:api` after backend API changes
- Generated code is gitignored by default (add to `.gitignore`)

## Storybook

### Overview

Storybook provides an isolated development environment for building, testing, and documenting UI components independently from the main application. This project uses Storybook 10+ with Next.js integration and MSW for API mocking.

**Benefits**:

- Develop components in isolation
- Visual testing and documentation
- Interactive component playground
- Accessibility testing with addon-a11y
- API mocking with MSW
- Theme switching (light/dark)
- Automatic documentation generation

### Commands

```bash
# Start Storybook development server
pnpm storybook

# Build Storybook for production (static site)
pnpm build-storybook
```

Access Storybook at [http://localhost:6006](http://localhost:6006)

### Configuration

Storybook is configured in `.storybook/` directory:

#### `.storybook/main.ts`

```typescript
import type { StorybookConfig } from '@storybook/nextjs-vite';

const config: StorybookConfig = {
  stories: ['../src/**/*.mdx', '../src/**/*.stories.@(js|jsx|mjs|ts|tsx)'],
  addons: [
    '@chromatic-com/storybook',
    '@storybook/addon-vitest',
    '@storybook/addon-a11y',
    '@storybook/addon-themes',
    '@storybook/addon-docs',
    '@storybook/addon-onboarding',
  ],
  framework: '@storybook/nextjs-vite',
  staticDirs: ['../public'],
  typescript: {
    reactDocgen: 'react-docgen-typescript',
  },
};
export default config;
```

**Key Configuration Points**:

- **stories**: Glob patterns to find story files (`*.stories.tsx`)
- **framework**: Uses `@storybook/nextjs-vite` for Next.js + Vite integration
- **staticDirs**: Serves `public/` folder for static assets
- **typescript.reactDocgen**: Auto-generates prop documentation from TypeScript types

#### `.storybook/preview.tsx`

```typescript
import type { Preview } from '@storybook/nextjs-vite';
import { withThemeByClassName } from '@storybook/addon-themes';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { initialize, mswLoader } from 'msw-storybook-addon';
import { handlers } from '../src/mocks/handlers';
import '../src/app/globals.css';

// Initialize MSW
initialize({
  onUnhandledRequest: 'bypass',
});

// Create React Query client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
      refetchOnWindowFocus: false,
    },
  },
});

const preview: Preview = {
  parameters: {
    nextjs: {
      appDirectory: true,
    },
    a11y: {
      test: 'todo', // Show a11y violations in UI
    },
    msw: {
      handlers,
    },
  },
  decorators: [
    withThemeByClassName({
      themes: {
        light: '',
        dark: 'dark',
      },
      defaultTheme: 'light',
    }),
    (Story) => (
      <QueryClientProvider client={queryClient}>
        <Story />
      </QueryClientProvider>
    ),
  ],
  loaders: [mswLoader],
};

export default preview;
```

**Key Configuration Points**:

- **MSW Initialization**: Mocks API requests in stories
- **React Query Provider**: Wraps all stories with QueryClientProvider
- **Theme Decorator**: Enables light/dark theme switching
- **Global Styles**: Imports Tailwind CSS
- **App Directory Support**: Configures Next.js App Router compatibility

### Story File Structure

Stories follow this naming convention and structure:

```typescript
// src/components/ui/button.stories.tsx
import type { Meta, StoryObj } from '@storybook/nextjs-vite';
import { Button } from './button';

// Meta configuration
const meta = {
  title: 'UI/Button', // Story hierarchy in sidebar
  component: Button, // Component to render
  parameters: {
    layout: 'centered', // Layout: 'centered', 'fullscreen', 'padded'
  },
  tags: ['autodocs'], // Generate documentation automatically
  argTypes: {
    variant: {
      control: 'select',
      options: ['default', 'destructive', 'outline', 'secondary', 'ghost', 'link'],
    },
    size: {
      control: 'select',
      options: ['default', 'sm', 'lg', 'icon'],
    },
  },
} satisfies Meta<typeof Button>;

export default meta;
type Story = StoryObj<typeof meta>;

// Individual stories
export const Default: Story = {
  args: {
    children: 'Button',
  },
};

export const Destructive: Story = {
  args: {
    variant: 'destructive',
    children: 'Delete',
  },
};
```

### Story Placement Rules

Stories are co-located with their components:

```
src/components/
├── ui/
│   ├── button.tsx
│   ├── button.stories.tsx       # Story for button
│   ├── dialog.tsx
│   └── dialog.stories.tsx       # Story for dialog
│
├── common/
│   ├── Loading.tsx
│   └── Loading.stories.tsx      # Story for Loading
│
└── messages/
    ├── MessageTable.tsx
    └── MessageTable.stories.tsx # Story for MessageTable
```

**Naming Convention**:

- Component: `ComponentName.tsx` (PascalCase)
- Story: `ComponentName.stories.tsx` (PascalCase with `.stories.tsx` suffix)

**Story Titles** (determines sidebar hierarchy):

- UI components: `UI/ComponentName` (e.g., `UI/Button`)
- Common components: `Common/ComponentName` (e.g., `Common/Loading`)
- Message components: `Messages/ComponentName` (e.g., `Messages/MessageTable`)

### MSW Integration

Mock Service Worker (MSW) allows stories to mock API requests without running the backend.

#### Setting Up MSW Handlers

```typescript
// src/mocks/handlers.ts
import { http, HttpResponse } from 'msw';

export const handlers = [
  // Mock GET /api/messages
  http.get('http://localhost:8080/api/messages', () => {
    return HttpResponse.json([
      { id: 1, code: 'MSG001', content: 'Test message 1' },
      { id: 2, code: 'MSG002', content: 'Test message 2' },
    ]);
  }),

  // Mock POST /api/messages
  http.post('http://localhost:8080/api/messages', async ({ request }) => {
    const body = await request.json();
    return HttpResponse.json({
      id: 999,
      ...body,
    });
  }),
];
```

#### Using MSW in Stories

```typescript
// src/components/messages/MessageTable.stories.tsx
import type { Meta, StoryObj } from '@storybook/nextjs-vite';
import { http, HttpResponse } from 'msw';
import { MessageTable } from './MessageTable';

const meta = {
  title: 'Messages/MessageTable',
  component: MessageTable,
  parameters: {
    layout: 'fullscreen',
  },
} satisfies Meta<typeof MessageTable>;

export default meta;
type Story = StoryObj<typeof meta>;

// Default story (uses global handlers from src/mocks/handlers.ts)
export const Default: Story = {};

// Override MSW handlers for specific story
export const Loading: Story = {
  parameters: {
    msw: {
      handlers: [
        http.get('http://localhost:8080/api/messages', async () => {
          await new Promise((resolve) => setTimeout(resolve, 3000)); // Simulate slow API
          return HttpResponse.json([]);
        }),
      ],
    },
  },
};

// Error state
export const ErrorState: Story = {
  parameters: {
    msw: {
      handlers: [
        http.get('http://localhost:8080/api/messages', () => {
          return HttpResponse.json({ message: 'Internal Server Error' }, { status: 500 });
        }),
      ],
    },
  },
};
```

**MSW Handler Options**:

- **Global Handlers**: Defined in `src/mocks/handlers.ts`, applied to all stories
- **Story-specific Handlers**: Override global handlers per story via `parameters.msw.handlers`
- **Response Delay**: Use `await new Promise()` to simulate slow APIs
- **Error States**: Return error status codes to test error handling

### Addons

#### Accessibility Testing (addon-a11y)

Automatically tests components for accessibility issues:

```typescript
const meta = {
  title: 'UI/Button',
  component: Button,
  parameters: {
    a11y: {
      test: 'todo', // 'todo', 'error', or 'off'
    },
  },
} satisfies Meta<typeof Button>;
```

- **`test: 'todo'`**: Show violations in Storybook UI (default)
- **`test: 'error'`**: Fail CI on violations
- **`test: 'off'`**: Skip a11y checks

**Common A11y Checks**:

- Color contrast ratios
- ARIA labels
- Keyboard navigation
- Form labels
- Semantic HTML

#### Theme Switching (addon-themes)

Switch between light and dark themes:

- Configured in `.storybook/preview.tsx` with `withThemeByClassName`
- Uses Tailwind's `dark:` class strategy
- Theme toggle appears in Storybook toolbar

#### Auto-generated Documentation (addon-docs)

```typescript
const meta = {
  title: 'UI/Button',
  component: Button,
  tags: ['autodocs'], // Enable automatic documentation
  argTypes: {
    variant: {
      description: 'Button visual variant',
      control: 'select',
      options: ['default', 'destructive', 'outline', 'secondary', 'ghost', 'link'],
    },
  },
} satisfies Meta<typeof Button>;
```

**Generated Documentation Includes**:

- Component description (from JSDoc comments)
- Prop types table (from TypeScript types)
- Interactive controls (from argTypes)
- Stories with code snippets

### Best Practices

#### 1. Co-locate Stories with Components

```
✅ Good: src/components/ui/button.tsx + button.stories.tsx
❌ Bad:  src/components/ui/button.tsx + stories/button.stories.tsx
```

#### 2. Use Descriptive Story Names

```typescript
✅ Good: export const DisabledState: Story = { ... }
❌ Bad:  export const Story1: Story = { ... }
```

#### 3. Use Args, Not Hardcoded Props

```typescript
✅ Good:
export const Primary: Story = {
  args: {
    variant: 'default',
    children: 'Click me',
  },
};

❌ Bad:
export const Primary: Story = {
  render: () => <Button variant="default">Click me</Button>,
};
```

#### 4. Mock API Responses with MSW

```typescript
✅ Good: Use MSW handlers to mock API calls
❌ Bad:  Hardcode data directly in component stories
```

#### 5. Test Different States

Create stories for:

- Default state
- Loading state
- Error state
- Empty state
- Disabled state
- Edge cases (long text, no data, etc.)

#### 6. Use Tags for Documentation

```typescript
const meta = {
  tags: ['autodocs'], // Generate docs automatically
} satisfies Meta<typeof Component>;
```

### Workflow

#### Daily Development with Storybook

1. **Start Storybook**: `pnpm storybook` (port 6006)
2. **Create Component**: Add new component in `src/components/`
3. **Create Story**: Add `.stories.tsx` file next to component
4. **Develop in Isolation**: Use Storybook UI to develop and test
5. **Test Accessibility**: Check a11y panel for violations
6. **Test Themes**: Switch between light/dark themes
7. **Document**: Add JSDoc comments and argTypes for better docs

#### Creating a New Story

1. **Create Story File**:

   ```bash
   touch src/components/ui/new-component.stories.tsx
   ```

2. **Define Meta and Stories**:

   ```typescript
   import type { Meta, StoryObj } from '@storybook/nextjs-vite';
   import { NewComponent } from './new-component';

   const meta = {
     title: 'UI/NewComponent',
     component: NewComponent,
     tags: ['autodocs'],
   } satisfies Meta<typeof NewComponent>;

   export default meta;
   type Story = StoryObj<typeof meta>;

   export const Default: Story = {
     args: {
       // component props
     },
   };
   ```

3. **View in Storybook**: Navigate to `UI/NewComponent` in sidebar

#### Testing with MSW

1. **Define Handlers**: Add handlers to `src/mocks/handlers.ts`
2. **Use in Story**: Override via `parameters.msw.handlers` if needed
3. **Test Different Responses**: Success, error, loading, empty

### Component Coverage

This project has 17 Storybook stories covering:

**UI Components (8)**:

1. Badge (`src/components/ui/badge.stories.tsx`)
2. Button (`src/components/ui/button.stories.tsx`)
3. Card (`src/components/ui/card.stories.tsx`)
4. Dialog (`src/components/ui/dialog.stories.tsx`)
5. Form (`src/components/ui/form.stories.tsx`)
6. Input (`src/components/ui/input.stories.tsx`)
7. Label (`src/components/ui/label.stories.tsx`)
8. Table (`src/components/ui/table.stories.tsx`)

**Common Components (3)**:

9. ErrorMessage (`src/components/common/ErrorMessage.stories.tsx`)
10. Loading (`src/components/common/Loading.stories.tsx`)
11. PageHeader (`src/components/common/PageHeader.stories.tsx`)

**Message Components (6)**:

12. DeleteConfirmDialog (`src/components/messages/DeleteConfirmDialog.stories.tsx`)
13. MessageForm (`src/components/messages/MessageForm.stories.tsx`)
14. MessageModal (`src/components/messages/MessageModal.stories.tsx`)
15. MessageTable (`src/components/messages/MessageTable.stories.tsx`)
16. Pagination (`src/components/messages/Pagination.stories.tsx`)
17. SearchBar (`src/components/messages/SearchBar.stories.tsx`)

### Troubleshooting

#### Storybook Won't Start

```bash
# Clear Storybook cache
pnpm storybook --no-manager-cache

# Reinstall dependencies
rm -rf node_modules pnpm-lock.yaml
pnpm install
```

#### MSW Not Working

- Check `src/mocks/handlers.ts` exists
- Verify `initialize()` is called in `.storybook/preview.tsx`
- Check browser console for MSW errors
- Ensure API URL matches handler URLs

#### Stories Not Showing

- Check file naming: `*.stories.tsx`
- Verify `stories` glob pattern in `.storybook/main.ts`
- Restart Storybook: `Ctrl+C` and `pnpm storybook`

#### Type Errors in Stories

- Ensure `@storybook/nextjs-vite` types are installed
- Check `Meta<typeof Component>` matches component type
- Verify `args` match component props

### Resources

- [Storybook Documentation](https://storybook.js.org/docs)
- [Next.js Integration](https://storybook.js.org/docs/nextjs/get-started/install)
- [MSW Documentation](https://mswjs.io/docs/)
- [Addon A11y](https://storybook.js.org/addons/@storybook/addon-a11y)

## Validation Rules

```typescript
// src/lib/validations/message.ts
import { z } from 'zod';

export const messageSchema = z.object({
  code: z.string().min(1, 'Code is required').max(50, 'Code must be 50 characters or less'),
  content: z
    .string()
    .min(1, 'Content is required')
    .max(500, 'Content must be 500 characters or less'),
});

export type MessageFormData = z.infer<typeof messageSchema>;
```

## Error Handling

### Client-side Errors

- **Validation Errors**: Display under form fields
- **Network Errors**: Show error message in modal/form
- **Not Found**: Display "Message not found" message

### Server-side Errors

- **400 Bad Request**: Display validation errors from server
- **404 Not Found**: Display "Message not found"
- **409 Conflict**: Display "Code already exists"
- **500 Server Error**: Display "An error occurred. Please try again."

## Responsive Design

### Breakpoints (Tailwind CSS defaults)

- `sm`: 640px
- `md`: 768px
- `lg`: 1024px
- `xl`: 1280px
- `2xl`: 1536px

### Mobile Considerations

- Table → Card layout on small screens (< 768px)
- Modal → Full screen on mobile
- Touch-friendly button sizes (min 44x44px)
- Readable font sizes (min 16px to prevent zoom on iOS)

## Testing Strategy

### Unit Tests (Vitest)

- Utility functions
- Validation schemas
- Custom hooks (with React Hooks Testing Library)

### Component Tests (Vitest + Testing Library)

- MessageTable rendering and interactions
- MessageForm validation
- Modal open/close behavior
- Search and filter functionality

### E2E Tests (Playwright)

- Complete CRUD flow
- Error handling scenarios
- Responsive behavior
- Accessibility (keyboard navigation, screen readers)

### Coverage Guidelines

#### Coverage Thresholds

- **Lines**: 80%
- **Functions**: 80%
- **Branches**: 70%
- **Statements**: 80%

#### Coverage Exclusion Policy

**Files that should be excluded from coverage:**

1. **Auto-generated Code**
   - Orval-generated API client (`src/lib/api/generated/**`)
   - TypeScript declaration files (`**/*.d.ts`)
   - Build artifacts (`.next/**`, `dist/**`)

2. **Framework Entry Points**
   - Next.js App Router files (`src/app/layout.tsx`, `src/app/page.tsx`)
   - Provider wrappers with minimal logic (`src/app/providers.tsx`)
   - **Rationale**: These files are integration points tested by E2E tests, not unit tests

3. **Infrastructure Configuration**
   - HTTP client configuration (`src/lib/api/client.ts`)
   - React Query client setup (`src/lib/query-client.ts`)
   - **Rationale**: Environment-dependent configuration with minimal business logic

4. **Unused Components**
   - Components not yet integrated into the application
   - **Rationale**: Testing unused code provides no value; test when integrated

5. **Test Infrastructure**
   - Test setup files (`tests/setup.ts`)
   - E2E test helpers and configuration (`playwright/**`)
   - **Rationale**: Testing the test infrastructure itself is meta-testing with low ROI

**When to exclude a file:**

- The file has no business logic (pure configuration/wiring)
- The file is covered indirectly by integration/E2E tests
- The file is auto-generated by tools
- The file is currently unused in the application

**When NOT to exclude:**

- Components with business logic (even if simple)
- Utility functions with conditional logic
- Custom hooks with state management
- Validation schemas
- Error handling logic

## Future Enhancements

### Planned Features

- **Authentication**: NextAuth.js integration
- **i18n**: next-intl for multi-language support (Japanese, English)
- **Dark Mode**: next-themes + Tailwind dark mode
- **Toast Notifications**: sonner or react-hot-toast
- **Export**: CSV/Excel export functionality
- **Bulk Operations**: Select multiple messages for bulk delete

### Architecture Considerations

- Prepare component structure for auth integration
- Use translation keys in UI text for easy i18n migration
- Design system ready for theme switching

## Code Style Guidelines

- **Components**: Use functional components with TypeScript
- **Props**: Define explicit prop types with interface/type
- **Hooks**: Extract reusable logic into custom hooks
- **File naming**:
  - Components: PascalCase (MessageTable.tsx)
  - Hooks: camelCase with 'use' prefix (useMessages.ts)
  - Utils: camelCase (formatDate.ts)
- **Exports**: Prefer named exports over default exports
- **Comments**: Use JSDoc for complex functions

## Development Workflow

### Initial Setup

1. Install dependencies: `pnpm install`
2. Generate API client: `pnpm generate:api`
3. Create `.env.local` with environment variables

### Daily Development

1. **Start backend**: `cd backend && ./mvnw spring-boot:run` (port 8080)
2. **Start frontend**: `cd frontend && pnpm dev` (port 3000)
3. Access app at http://localhost:3000
4. API requests go to http://localhost:8080/api

### After Backend API Changes

1. **Backend**: Regenerate OpenAPI spec

   ```bash
   cd backend
   ./mvnw verify
   ```

2. **Frontend**: Regenerate API client

   ```bash
   cd frontend
   pnpm generate:api
   ```

3. TypeScript will now show type errors if API contract changed
4. Update components to match new API types

## Environment Variables

Create `.env.local`:

```bash
NEXT_PUBLIC_API_URL=http://localhost:8080/api
```

## Accessibility (a11y)

- Use semantic HTML
- ARIA labels for interactive elements
- Keyboard navigation support (Tab, Enter, Escape)
- Focus management in modals
- Color contrast ratios meet WCAG AA standards

## Performance Optimization

- Use TanStack Query for caching and background refetching
- Debounce search input (300ms)
- Lazy load heavy components if needed
- Optimize images with Next.js Image component
- Code splitting with dynamic imports

## shadcn/ui Components Used

Initialize and add components as needed:

```bash
npx shadcn@latest init
npx shadcn@latest add button
npx shadcn@latest add table
npx shadcn@latest add dialog
npx shadcn@latest add form
npx shadcn@latest add input
npx shadcn@latest add label
npx shadcn@latest add select
npx shadcn@latest add toast
```

## Notes

- This is a sandbox project for experimenting with Claude Code
- Backend API follows Clean Architecture (see backend/CLAUDE.md)
- Use the latest stable versions of all dependencies
- Follow Next.js App Router best practices
- Maintain type safety throughout the application
